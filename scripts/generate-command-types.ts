#!/usr/bin/env bun
/**
 * Script to automatically generate command type definitions based on the file structure
 *
 * This script scans the src/commands directory and creates a types file with:
 * - CommandModule types (for top-level directories)
 * - Subcommand types for each module and nested subcommands
 * - A comprehensive Commands union type
 *
 * Run with: bun scripts/generate-command-types.ts
 */

import {
	existsSync,
	mkdirSync,
	readdirSync,
	statSync,
	writeFileSync,
} from "node:fs";
import { dirname, join, resolve } from "node:path";

// Configuration
const COMMANDS_DIR = resolve(process.cwd(), "src/commands");
const OUTPUT_FILE = resolve(process.cwd(), "src/types/commands.ts");
const SPECIAL_MAPPINGS: Record<string, string> = {
	// Add special case mappings where folder name != command name
	// Format: 'folderName': 'commandName'
	songs: "song",
};

// Type to represent a command tree
interface CommandTree {
	name: string;
	path: string[];
	children: CommandTree[];
}

// Ensure directories exist
function ensureDirectoryExists(filePath: string) {
	const dir = dirname(filePath);

	if (existsSync(dir)) return;

	ensureDirectoryExists(dir);
	mkdirSync(dir);
}

// Get all subdirectories of a directory
function getSubdirectories(dir: string): string[] {
	// Get all entries
	const entries = readdirSync(dir);

	// Filter to only include directories
	return entries.filter((entry) => {
		const fullPath = join(dir, entry);
		// Check if it's a directory
		try {
			return statSync(fullPath).isDirectory();
		} catch (error) {
			return false;
		}
	});
}

// Convert directory name to command name
function dirToCommandName(dir: string): string {
	return SPECIAL_MAPPINGS[dir] || dir;
}

// Build a command tree recursively
function buildCommandTree(
	basePath: string,
	currentPath: string[] = [],
): CommandTree[] {
	const dirPath = join(basePath, ...currentPath);
	const dirs = getSubdirectories(dirPath);

	return dirs.map((dir) => {
		const commandName = dirToCommandName(dir);
		const newPath = [...currentPath, dir];

		// Create this node
		const node: CommandTree = {
			name: commandName,
			path: newPath,
			children: [],
		};

		// Recursively process children
		node.children = buildCommandTree(basePath, newPath);

		return node;
	});
}

// Generate complete command paths
function generateCommandPaths(tree: CommandTree[], prefix = ""): string[] {
	let results: string[] = [];

	for (const node of tree) {
		// Create the command path
		const commandPath = prefix ? `${prefix}:${node.name}` : node.name;

		// Add this command
		results.push(commandPath);

		// Add all child commands
		if (node.children.length > 0) {
			results = [
				...results,
				...generateCommandPaths(node.children, commandPath),
			];
		}
	}

	return results;
}

// Generate the type definitions file
function generateCommandTypes() {
	// Build the command tree
	const commandTree = buildCommandTree(COMMANDS_DIR);

	// Generate all command paths
	const allCommandPaths = generateCommandPaths(commandTree);

	// Group commands by their top-level module
	const commandsByModule: Record<string, string[]> = {};

	for (const path of allCommandPaths) {
		const parts = path.split(":");
		const module = parts[0];

		if (!commandsByModule[module]) {
			commandsByModule[module] = [];
		}

		commandsByModule[module].push(path);
	}

	// Build type definitions
	let output = `/**
 * AUTOMATICALLY GENERATED FILE - DO NOT EDIT DIRECTLY
 * 
 * This file was generated by scripts/generate-command-types.ts
 * To update, run: bun run generate-types
 * 
 * Type definitions for CLI commands based on directory structure in src/commands/
 * - Root commands (module) become "module" (e.g., "spotify")
 * - First-level subcommands become "module:subcommand" (e.g., "spotify:playlists")
 * - Nested subcommands become "module:subcommand:subsubcommand" (e.g., "spotify:playlists:test")
 */

`;

	// Generate CommandModule type
	const topLevelModules = Object.keys(commandsByModule);
	output += `/**
 * Base command modules (top-level directories in src/commands/)
 */
export type CommandModule = 
${topLevelModules.map((module) => `  | "${module}"`).join("\n")};

`;

	// Generate subcommand types for each module
	for (const module of topLevelModules) {
		const commands = commandsByModule[module]
			.filter((cmd) => cmd.includes(":")) // Only include subcommands
			.map((cmd) => cmd.substring(module.length + 1)); // Remove the module prefix + colon

		if (commands.length > 0) {
			// Group commands by depth
			const byDepth: Record<number, string[]> = {};
			for (const cmd of commands) {
				const depth = cmd.split(":").length;
				if (!byDepth[depth]) byDepth[depth] = [];
				byDepth[depth].push(cmd);
			}

			// Generate type for first-level subcommands
			const firstLevelCommands = commands
				.filter((cmd) => !cmd.includes(":"))
				.map((cmd) => {
					const folderName = cmd;
					const commandName = dirToCommandName(folderName);
					const comment =
						commandName !== folderName
							? ` // Maps to ${folderName}/ directory`
							: "";
					return `  | "${commandName}"${comment}`;
				});

			output += `/**
 * ${module} direct subcommands (first-level subdirectories in src/commands/${module}/)
 */
export type ${module.charAt(0).toUpperCase() + module.slice(1)}Subcommand = 
${firstLevelCommands.join("\n")};

`;

			// Generate nested command types if they exist
			const nestedCommands = commands.filter((cmd) => cmd.includes(":"));
			if (nestedCommands.length > 0) {
				output += `/**
 * ${module} nested commands (includes all levels of nesting)
 * These follow the pattern "subcommand:subsubcommand[:...]"
 */
export type ${module.charAt(0).toUpperCase() + module.slice(1)}NestedCommand = 
  | ${module.charAt(0).toUpperCase() + module.slice(1)}Subcommand
  | "${nestedCommands.join('"\n  | "')}"
;

`;
			}
		}
	}

	// Generate the complete Commands type
	output += `/**
 * All available commands based on directory structure
 */
export type Commands = 
  | CommandModule
${Object.keys(commandsByModule)
	.map((module) => {
		const nestedType = `${module.charAt(0).toUpperCase() + module.slice(1)}NestedCommand`;
		const basicType = `${module.charAt(0).toUpperCase() + module.slice(1)}Subcommand`;

		// Check if nested commands exist for this module
		const hasNestedCommands = commandsByModule[module].some(
			(cmd) => cmd.includes(":") && cmd.split(":").length > 2,
		);

		if (hasNestedCommands) {
			// If we have nested commands, use the module's nested command type
			return `  | \`${module}:\${${nestedType}}\``;
		}
		// If we only have first-level subcommands, use the basic subcommand type
		return `  | \`${module}:\${${basicType}}\``;
	})
	.join("\n")};
`;

	// Write the file
	ensureDirectoryExists(OUTPUT_FILE);
	writeFileSync(OUTPUT_FILE, output);

	console.log(`Command type definitions generated at ${OUTPUT_FILE}`);
}

// Run the generator
generateCommandTypes();
